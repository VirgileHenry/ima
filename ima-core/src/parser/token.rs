/// Created by Virgile HENRY, 2023/09/28

use super::label::Label;


/// Token for any ima program. This is mostly a quick abstraction 
/// over labels, comments and strings rather than a real token.
/// It have been added to avoid all the errors generated by string previously.
#[derive(Debug, Clone)]
pub enum Token {
    /// A label token.
    Label(Label),
    /// A comment token.
    Comment(String),
    /// Any assembly token: opcode, register, data type, string, etc.
    Assembly(String),
}

pub(super) fn lex(input: &str) -> Result<Vec<Vec<Token>>, ()> {
    
    let label_regex = regex::Regex::new(r"^[a-zA-Z][a-zA-Z0-9_\.]*[ ]*:").unwrap();
    let comment_regex = regex::Regex::new(r";.*$").unwrap();
    
    let mut result = Vec::new();
    let lines = input.split("\n");

    for line in lines {
        let mut tokens = Vec::new();
        let mut line = line;

        while let Some(captures) = label_regex.captures(line) {
            let capture = captures.get(0).unwrap();
            tokens.push(Token::Label(Label::from_str(line[capture.start()..capture.end()-1].trim()).unwrap()));
            line = line[capture.end()..].trim();
        }

        if let Some(captures) = comment_regex.captures(line) {
            let capture = captures.get(0).unwrap();
            tokens.push(Token::Comment(capture.as_str().to_string()));
            line = &line[..capture.start()];
        }

        if !line.trim().is_empty() {
            // todo : this uppercases printed text, better solution to find.
            tokens.push(Token::Assembly(line.trim().to_uppercase()));
        }
        result.push(tokens);
    }

    Ok(result)
}